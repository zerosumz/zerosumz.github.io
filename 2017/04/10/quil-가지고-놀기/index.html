<!DOCTYPE html><html><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="alternative" href="/atom.xml" title="(loop (print (eval (read))))" type="application/atom+xml"><link rel="icon" href="/favicon.png"><title>quil 가지고 놀기 - (loop (print (eval (read))))</title><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Code+Pro"><link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Handlee" type="text/css"><style type="text/css">.fb-share-button , .twitter-share-button {
  vertical-align: text-bottom;
  margin-left : 5px;
}
</style><link rel="stylesheet" href="/css/main.css"><!--[if lt IE 9]><script>(function(a,b){a="abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output progress section summary template time video".split(" ");for(b=a.length-1;b>=0;b--)document.createElement(a[b])})()</script><![endif]--><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"] ],
    processEscapes: true
  }
});</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  }
});</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for(i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type="text/javascript">var switchTo5x=true;</script><script type="text/javascript" src="http://w.sharethis.com/button/buttons.js"></script><script type="text/javascript">stLight.options({publisher: "3df02cad-979e-4347-be4c-94fe98b99af9", doNotHash: false, doNotCopy: false, hashAddressBar: false});</script></head><body><div id="fb-root"></div><script type="text/javascript">(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) return;
    js = d.createElement(s); js.id = id;
    js.src = "//connect.facebook.net/ko_KR/sdk.js#xfbml=1&appId=783844121725729&version=v2.0";
    fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script><script type="text/javascript">!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script><header class="head"><h1 class="head-title u-fl"><a href="/">(loop (print (eval (read))))</a></h1><h4 class="sub-title u-fl">;;닭집을 차리기 위한 여정</h4><nav class="head-nav u-fr"><ul class="head-nav__list"><li class="head-nav__item"><a href="/" class="head-nav__link">Home</a></li></ul></nav></header><main class="main"><article class="post"><header class="post__head"><time datetime="2017-04-10T05:12:41.000Z" class="post__time">4월 10, 2017</time><h1 class="post__title"> <a href="/2017/04/10/quil-가지고-놀기/">quil 가지고 놀기</a><div style="float:right;"><div data-href="/2017/04/10/quil-가지고-놀기/" data-layout="button_count" class="fb-share-button"></div><a href="https://twitter.com/share" data-url="http://zerosumz.github.io/2017/04/10/quil-가지고-놀기/" data-via="k_racketeer" class="twitter-share-button"></a></div></h1></header><div class="post__main echo"><h2 id="클로져-브릿지-행사를-마치고"><a href="#클로져-브릿지-행사를-마치고" class="headerlink" title="클로져 브릿지 행사를 마치고"></a>클로져 브릿지 행사를 마치고</h2><p>귀차니즘의 영향으로 분명 늦은 포스팅이지만 상당히 인상깊은 행사였다고 생각하며 꼭 블로그에 글 써야지 하고 생각했던 행사였다.<br>사람들이 정말 전통적인 소프트웨어 강의를 얼마나 익숙치 않아하고 반대로 눈에 보이는 그래픽-한 과제에는 흥미를 보이는구나.<br>생각해보면 이런 종류의 교육용 커리큘럼은 <code>plt-racket</code>에 이미 있었고 꽤 흥미로웠던 기억이 난다.<br>그런데 <code>plt-racket</code>에 있는 <code>http2/image</code> 패키지랑은 다르게 <code>quil</code>은 좀 더 낮은 api만 제공하므로 이 글을 쓰는 계기가 됨.</p>
<h2 id="quil로-도형-그리기"><a href="#quil로-도형-그리기" class="headerlink" title="quil로 도형 그리기 "></a>quil로 도형 그리기 </h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">lein new quil foo</div></pre></td></tr></table></figure>
<p>정도의 명령어로 quil 라이브러리가 포함되고 실행만 하면 되는 얼개가 구현된 상태의 quil 프로젝트가 만들어진다. </p>
<p>기본적으로 생성되는 프로젝트는 사실 너무 복잡하므로 그냥 도형만 그려보는 것으로 수정..</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">ns</span></span> foo.core</div><div class="line">  (<span class="symbol">:require</span> [quil.core <span class="symbol">:refer</span> <span class="symbol">:all</span>]</div><div class="line">            [quil.middleware <span class="symbol">:as</span> m]))</div><div class="line"></div><div class="line">(<span class="name"><span class="builtin-name">defn</span></span> setup []</div><div class="line">  (<span class="name">frame-rate</span> <span class="number">30</span>)</div><div class="line">  (<span class="name">color-mode</span> <span class="symbol">:rgb</span>))</div><div class="line"></div><div class="line">(<span class="name"><span class="builtin-name">defn</span></span> draw-state [state]</div><div class="line">  (<span class="name">background</span> <span class="number">255</span> <span class="number">255</span> <span class="number">255</span>)</div><div class="line">  (<span class="name">fill</span> <span class="number">255</span> <span class="number">0</span> <span class="number">0</span>) <span class="comment">;; red</span></div><div class="line">  (<span class="name">rect</span> <span class="number">75</span> <span class="number">75</span> <span class="number">50</span> <span class="number">50</span>))</div><div class="line">  </div><div class="line">(<span class="name">defsketch</span> foo</div><div class="line">  <span class="symbol">:title</span> <span class="string">"foo"</span></div><div class="line">  <span class="symbol">:size</span> [<span class="number">200</span> <span class="number">200</span>]</div><div class="line">  <span class="symbol">:setup</span> setup</div><div class="line">  <span class="symbol">:draw</span> draw-state</div><div class="line">  <span class="symbol">:features</span> [<span class="symbol">:keep-on-top</span>]</div><div class="line">  <span class="symbol">:middleware</span> [m/fun-mode])</div></pre></td></tr></table></figure>
<img src="/2017/04/10/quil-가지고-놀기/red_rect.png" alt="red_rect.png" title="">
<p>일단은 여기서 <code>draw-state</code> 함수만 고치면 뭔가를 그려볼 수 있는 상태가 됨.<br>라켓의 <code>http2/image</code> 패키지에는 여러 레이아웃 함수들이 있어 편리하다. 그래서 그런걸 만들어보려는 마음이 생겼다.</p>
<p>처음 만들어 볼 것은 여러 모양을 가로로 늘어놓는 모양을 만드는 <code>beside</code>를 만들어보자.<br>그럴려면 모든 모양들은 아직 그려지지 않은 상태에서 그려지기 위한 데이터를 가지고 있어야 하며, 또한 한 가지 원칙으로 그려져야 괜찮을 것 같다-예를들어 삼각형은 각 꼭지점의 위치를 인자로 줘야 하는데 사각형과 마찬가지로 그냥 <code>좌-상단위치</code>와 가로길이,세로길이 를 인자로 받도록 하는게 더 좋을듯.</p>
<p>그럼 <code>그리기!</code> 함수를 한번 생각해보면 <code>그리기!</code>는 어떤 <code>모양</code>을 그리든지 나머지는 <code>모양</code>이 가진 데이터에 기초해서 그리되 함께 넘겨받은 <code>left</code> 위치와 <code>top</code> 위치 인자를 가지고 그리도록 하는게 좋겠다.</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">defn</span></span> 그리기!</div><div class="line">  <span class="string">"좌-상단 위치를 기준으로 모양을 그린다."</span></div><div class="line">  [left top 모양]</div><div class="line">  (<span class="name">rect</span> left</div><div class="line">        top</div><div class="line">        (<span class="symbol">:width</span> 모양)</div><div class="line">        (<span class="symbol">:heigth</span> 모양)))</div></pre></td></tr></table></figure>
<p>그리고 다음과 같이 <code>draw-state</code> 함수를 수정하면</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">defn</span></span> draw-state [state]</div><div class="line">  (<span class="name">background</span> <span class="number">255</span> <span class="number">255</span> <span class="number">255</span>)</div><div class="line">  (<span class="name">fill</span> <span class="number">255</span> <span class="number">0</span> <span class="number">0</span>) <span class="comment">;; red</span></div><div class="line">  (그리기! <span class="number">75</span> <span class="number">75</span> &#123;<span class="symbol">:width</span> <span class="number">50</span> <span class="symbol">:heigth</span> <span class="number">50</span>&#125;))</div></pre></td></tr></table></figure>
<p>이전과 동일하게 동작하게 된다.<br><code>그리기!</code> 함수는 무조건 <code>rect</code> 를 그리게 구현되었다. 이는 우리가 원한게 아니므로 <code>그리기!</code> 함수가 어떤 <code>모양</code>인지를 따져보고 알맞은 함수를 호출하도록 바꿔보자. 이럴때 단순히 조건분기하는 <code>if</code> 나 <code>cond</code>를 쓸 수도 있지만 어떤 <code>모양</code>인지 따져보고 알맞은 함수를 호출한다는 것은 clojure 에서 지원하는 문법인 <code>defmulti</code> 를 쓰기에 알맞아 보인다. <code>defmulti</code>는 실제 함수 구현부인 <code>defmethod</code> 와 짝을 이루며 인자를 살펴보거나 따져보아서 어떤 값을 기준으로 <code>method</code>를 호출할지 결정할 수 있고, <code>defmethod</code> 에서는 어떤 값에 따라 호출될지 구현부 앞에 밝혀적음으로써 누구나 의도를 파악하기 쉽도록 할 수 있다.</p>
<blockquote>
<p>하지만 한가지 문제가 있는데 <code>defmulti</code> 는 repl 이 다시 실행될때까지 덮어 써지지 않는다;;<br>수정하려면 뭔가 특별한 조치를 취하지 않는이상 ide 에서 프로젝트 커넥션등을 다시 실행하거나 해야한다는것..</p>
</blockquote>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">defmulti</span></span> 그리기!</div><div class="line">  <span class="string">"좌-상단 위치를 기준으로 모양을 그린다."</span></div><div class="line">  (<span class="name"><span class="builtin-name">fn</span></span> [_ _ 모양]   <span class="comment">;; _ 로 관심없는 인자를 표시..</span></div><div class="line">    (<span class="symbol">:type</span> 모양)))  <span class="comment">;; 어떤 값을 기준으로 할지 골라내는 방법</span></div><div class="line">	</div><div class="line">(<span class="name"><span class="builtin-name">defmethod</span></span> 그리기!</div><div class="line">  <span class="symbol">::rect</span>  <span class="comment">;; 골라낸 값이 일치하는 경우 실행될 메서드임을 밝힘.</span></div><div class="line">  [left top 모양]</div><div class="line">  (<span class="name">rect</span> left</div><div class="line">        top</div><div class="line">        (<span class="symbol">:width</span> 모양)</div><div class="line">        (<span class="symbol">:heigth</span> 모양)))</div></pre></td></tr></table></figure>
<p>여기서는 <code>모양</code> 맵의 <code>:type</code> 을 보고 <code>::rect</code> 인 경우에만 사각형을 그리도록 함수가 구현되어 있다. 이는 <code>모양</code> 맵이 <code>:type</code> 이 있음을 가정하고 있으므로 <code>draw-state</code> 함수는 다음과 같이 고쳐야 한다.</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">defn</span></span> draw-state [state]</div><div class="line">  (<span class="name">background</span> <span class="number">255</span> <span class="number">255</span> <span class="number">255</span>)</div><div class="line">  (<span class="name">fill</span> <span class="number">255</span> <span class="number">0</span> <span class="number">0</span>) <span class="comment">;; red</span></div><div class="line">  (그리기! <span class="number">75</span> <span class="number">75</span> &#123;<span class="symbol">:type</span>   <span class="symbol">::rect</span></div><div class="line">                  <span class="symbol">:width</span>  <span class="number">50</span></div><div class="line">                  <span class="symbol">:heigth</span> <span class="number">50</span>&#125;))</div></pre></td></tr></table></figure>
<p>어떤 <code>모양</code>을 그릴때 이 <code>모양</code>은 하나가 아닐 수 있다. 특히나 우리가 구현하려고 하는 <code>beside</code>는 각 모양들의 집합이다. 따라서 이 <code>모양</code>들의 <code>좌-상단</code>위치가 같아서는 안 된다. 이를 나타내는 <code>offset</code> 을 <code>모양</code>맵에 넣도록 하자. 덤으로 색깔도..</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">;; 그리기! 함수를 이렇게..</span></div><div class="line">(<span class="name"><span class="builtin-name">defmethod</span></span> 그리기!</div><div class="line">  <span class="symbol">::rect</span></div><div class="line">  [left top 모양]</div><div class="line">  (<span class="name"><span class="builtin-name">when</span></span> (<span class="symbol">:stroke</span> 모양)</div><div class="line">    (<span class="name"><span class="builtin-name">apply</span></span> stroke (<span class="symbol">:stroke</span> 모양))) <span class="comment">;; apply 를 썼다.</span></div><div class="line">  (<span class="name"><span class="builtin-name">when</span></span> (<span class="symbol">:fill</span> 모양)</div><div class="line">    (<span class="name"><span class="builtin-name">apply</span></span> fill (<span class="symbol">:fill</span> 모양)))  <span class="comment">;; apply 를 썼다.</span></div><div class="line">  (<span class="name">rect</span> (<span class="name"><span class="builtin-name">+</span></span> left (<span class="symbol">:offset-left</span> 모양))</div><div class="line">        (<span class="name"><span class="builtin-name">+</span></span> top (<span class="symbol">:offset-top</span> 모양))</div><div class="line">        (<span class="symbol">:width</span> 모양)</div><div class="line">        (<span class="symbol">:heigth</span> 모양)))</div><div class="line"></div><div class="line"><span class="comment">;; draw-state 함수를 이렇게...</span></div><div class="line">(<span class="name"><span class="builtin-name">defn</span></span> draw-state [state]</div><div class="line">  (<span class="name">background</span> <span class="number">255</span> <span class="number">255</span> <span class="number">255</span>)</div><div class="line">  (그리기! <span class="number">0</span> <span class="number">0</span> &#123;<span class="symbol">:type</span>   <span class="symbol">::rect</span></div><div class="line">                <span class="symbol">:fill</span> [<span class="number">255</span> <span class="number">0</span> <span class="number">0</span>]</div><div class="line">                <span class="symbol">:stroke</span> [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</div><div class="line">                <span class="symbol">:offset-left</span> <span class="number">75</span></div><div class="line">                <span class="symbol">:offset-top</span> <span class="number">75</span></div><div class="line">                <span class="symbol">:width</span>  <span class="number">50</span></div><div class="line">                <span class="symbol">:heigth</span> <span class="number">50</span>&#125;))</div></pre></td></tr></table></figure>
<p><code>stroke</code> 나 <code>fill</code> 함수는 인자들을 여러개를 받아서 색을 결정한다. 따라서 우리는 데이터를 벡터 형으로 기록하도록 하고 나중에 함수를 실행할때 벡터를 여러 인자를 넣어 실행한 것처럼 호출 해야한다. 이때 <code>apply</code> 라는 함수를 쓸 수 있다. 또, 어떤 경우에만 실행한다 라는 의미로 <code>when</code> 을 쓸 수 있다.<br>그리기! 메서드가 너무 길어져서 번잡해졌다. 한번 개선해보자.</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">defmethod</span></span> 그리기!</div><div class="line">  <span class="symbol">::rect</span></div><div class="line">  [left top 모양]</div><div class="line">  (<span class="name"><span class="builtin-name">let</span></span> [&#123;<span class="symbol">:keys</span> [offset-left</div><div class="line">                offset-top</div><div class="line">                width</div><div class="line">                height</div><div class="line">                stroke</div><div class="line">                fill]&#125; 모양]</div><div class="line">    (<span class="name"><span class="builtin-name">when</span></span> stroke</div><div class="line">      (<span class="name"><span class="builtin-name">apply</span></span> quil.core/stroke stroke))</div><div class="line">    (<span class="name"><span class="builtin-name">when</span></span> fill</div><div class="line">      (<span class="name"><span class="builtin-name">apply</span></span> quil.core/fill fill))</div><div class="line">    (<span class="name">rect</span> (<span class="name"><span class="builtin-name">+</span></span> left offset-left)</div><div class="line">          (<span class="name"><span class="builtin-name">+</span></span> top offset-top)</div><div class="line">          width</div><div class="line">          height)))</div></pre></td></tr></table></figure>
<p><code>let</code>은 내부에 밝혀적은 식대로 <code>destructuring</code>(구조분해) 해서 각 심볼로 그 값을 쓸 수 있게 해준다. 여기서는 <code>모양</code>맵을 구조분해 해서 각 <code>키워드</code>에 해당하는 값을 그대로 심볼로 쓸 수 있게 한 것.<br>그런데 여기서 <code>stroke</code>는 quil.core/stroke 함수를 가려버리게 되므로 stroke가 quil의 함수임을 밝혀적었다.</p>
<p>이제 <code>beside</code> 를 만들어보자.</p>
<p>옆으로 늘어놓을때, 각각의 세로길이가 다른 <code>모양</code>을 늘어놓을 것이므로 이 <code>모양</code>들은 세로 기준 중앙 정렬 되어야 할 것이다.</p>
<p>그러므로 먼저 <code>모양</code>들 중 가장 긴 <code>세로</code>길이 를 구해야 하고,<br><figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">apply</span></span> max (<span class="name"><span class="builtin-name">map</span></span> <span class="symbol">:height</span> 모양들)) <span class="comment">;; 모양들의 가장-긴-세로길이 를 구한다.</span></div></pre></td></tr></table></figure></p>
<p> 이 <code>가장 긴 세로길이</code>를 기준으로 <code>offset-top</code> 을 바꿔줘야 한다.</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">quot</span></span> (<span class="name"><span class="builtin-name">-</span></span> 가장-긴-세로길이 height) <span class="number">2</span>) <span class="comment">;; 각 모양의 (가장-긴-세로길이 - 세로길이) / 2</span></div></pre></td></tr></table></figure>
<p>또한 모든 모양들에 대해서 앞선 모양의 <code>offset-left</code> 에 현재 모양의 가로길이를 더한것이 다음번 모양의 <code>offset-left</code> 가 된다.</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">defn</span></span> beside</div><div class="line">  <span class="string">"모양들을 옆으로 늘어놓는다. 이때 세로가 가장 긴 모양의 세로축 중심을 기준으로 중앙정렬한다."</span></div><div class="line">  [&amp; 모양들]</div><div class="line">  (<span class="name"><span class="builtin-name">let</span></span> [가장-긴-세로길이 (<span class="name"><span class="builtin-name">apply</span></span> max (<span class="name"><span class="builtin-name">map</span></span> <span class="symbol">:height</span> 모양들))</div><div class="line">        자식요소   (<span class="name"><span class="builtin-name">loop</span></span> [모양들 모양들</div><div class="line">                          left   <span class="number">0</span></div><div class="line">                          result []]</div><div class="line">                     (<span class="name"><span class="builtin-name">if</span></span> 모양들</div><div class="line">                       (<span class="name"><span class="builtin-name">let</span></span> [[이번-모양 &amp; 남은-모양] 모양들</div><div class="line">                             &#123;<span class="symbol">:keys</span> [width height]&#125; 이번-모양</div><div class="line">                             top (<span class="name"><span class="builtin-name">quot</span></span> (<span class="name"><span class="builtin-name">-</span></span> 가장-긴-세로길이 height) <span class="number">2</span>)</div><div class="line">                             조정된-모양 (<span class="name"><span class="builtin-name">assoc</span></span> 이번-모양</div><div class="line">                                                <span class="symbol">:offset-left</span> left</div><div class="line">                                                <span class="symbol">:offset-top</span> top)] <span class="comment">;; 중앙정렬</span></div><div class="line">                        (<span class="name"><span class="builtin-name">recur</span></span> 남은-모양</div><div class="line">                               (<span class="name"><span class="builtin-name">+</span></span> left width) <span class="comment">;; 다음 모양은 현재 가로길이를 더한 값으로 offset-left 가 계산되도록 더해준다.</span></div><div class="line">                               (<span class="name"><span class="builtin-name">conj</span></span> result 조정된-모양)))</div><div class="line">                      result))]</div><div class="line">    &#123;<span class="symbol">:type</span>        <span class="symbol">::grouped</span> </div><div class="line">     <span class="symbol">:width</span>       (<span class="name"><span class="builtin-name">reduce</span></span> + (<span class="name"><span class="builtin-name">map</span></span> <span class="symbol">:width</span> 모양들)) <span class="comment">;; 모양들의 가로길이 합이 합쳐진 모양의 가로길이가 된다. </span></div><div class="line">     <span class="symbol">:height</span>      가장-긴-세로길이</div><div class="line">     <span class="symbol">:offset-left</span> <span class="number">0</span></div><div class="line">     <span class="symbol">:offset-top</span>  <span class="number">0</span></div><div class="line">     <span class="symbol">:children</span>    자식요소&#125;))</div></pre></td></tr></table></figure>
<p><code>&amp; 모양들</code>은 이 함수에 여러개의 인자를 넣어서 호출 할 수 있음을 밝히는 구문이다.<br><code>loop</code> 는 초기값을 선언하고 몸체내의 식을 <code>recur</code> 로 반복할 수 있도록 만든 설탕문법이다. <code>loop</code>는 다른 함수나 <code>letfn</code> 등으로 바꿔 쓸 수 있다. <code>assoc</code>은 해당 키의 값을 덮어 쓰는데 사용한다. </p>
<p>즉, <code>모양들</code> 을 순회하며 <code>offset-left</code> 와 <code>offset-top</code>을 갱신하는 코드가 된다.<br>마지막으로 이 결과를 가지고 <code>:type</code>이 <code>::grouped</code>인 <code>모양</code>맵을 만들어낸다.</p>
<p>이 <code>::grouped</code> 를 <code>그리기!</code>하는 <code>method</code>는 아직 없으므로 하나 만들어주자.</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">defmethod</span></span> 그리기!</div><div class="line">  <span class="symbol">::grouped</span></div><div class="line">  [left top 모양]</div><div class="line">  (<span class="name"><span class="builtin-name">let</span></span> [&#123;<span class="symbol">:keys</span> [type</div><div class="line">                offset-left</div><div class="line">                offset-top</div><div class="line">                width</div><div class="line">                height</div><div class="line">                children]&#125; 모양]</div><div class="line">    (<span class="name"><span class="builtin-name">doseq</span></span> [child children]</div><div class="line">      (그리기! (<span class="name"><span class="builtin-name">+</span></span> offset-left left)</div><div class="line">               (<span class="name"><span class="builtin-name">+</span></span> offset-top top)</div><div class="line">               child))))</div></pre></td></tr></table></figure>
<p><code>deseq</code> 는 다른 플랫폼의 <code>for-each</code> 구문과 비슷하게 동작한다. <code>child of children</code>을 모두 <code>그리기!</code>하는 함수이되 <code>::grouped</code> 모양도 결국은 <code>offset</code> 을 가지므로 이를 <code>좌-상단</code> 위치에 반영해준다.</p>
<p>이를 <code>draw-state</code> 함수를 고쳐 한번 테스트해보자.</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">defn</span></span> draw-state [state]</div><div class="line">  (<span class="name">background</span> <span class="number">255</span> <span class="number">255</span> <span class="number">255</span>)</div><div class="line">  (그리기! <span class="number">25</span> <span class="number">25</span> (<span class="name">beside</span></div><div class="line">                &#123;<span class="symbol">:type</span>       <span class="symbol">::rect</span></div><div class="line">                 <span class="symbol">:fill</span>        [<span class="number">255</span> <span class="number">0</span> <span class="number">0</span>]</div><div class="line">                 <span class="symbol">:stroke</span>      [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</div><div class="line">                 <span class="symbol">:offset-left</span> <span class="number">0</span></div><div class="line">                 <span class="symbol">:offset-top</span>  <span class="number">0</span></div><div class="line">                 <span class="symbol">:width</span>       <span class="number">25</span></div><div class="line">                 <span class="symbol">:height</span>      <span class="number">25</span>&#125;</div><div class="line">                &#123;<span class="symbol">:type</span>       <span class="symbol">::rect</span></div><div class="line">                 <span class="symbol">:fill</span>        [<span class="number">255</span> <span class="number">255</span> <span class="number">255</span>]</div><div class="line">                 <span class="symbol">:stroke</span>      [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</div><div class="line">                 <span class="symbol">:offset-left</span> <span class="number">0</span></div><div class="line">                 <span class="symbol">:offset-top</span>  <span class="number">0</span></div><div class="line">                 <span class="symbol">:width</span>       <span class="number">25</span></div><div class="line">                 <span class="symbol">:height</span>      <span class="number">25</span>&#125;</div><div class="line">                &#123;<span class="symbol">:type</span>       <span class="symbol">::rect</span></div><div class="line">                 <span class="symbol">:fill</span>        [<span class="number">255</span> <span class="number">0</span> <span class="number">0</span>]</div><div class="line">                 <span class="symbol">:stroke</span>      [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</div><div class="line">                 <span class="symbol">:offset-left</span> <span class="number">0</span></div><div class="line">                 <span class="symbol">:offset-top</span>  <span class="number">0</span></div><div class="line">                 <span class="symbol">:width</span>       <span class="number">25</span></div><div class="line">                 <span class="symbol">:height</span>      <span class="number">25</span>&#125;)))</div></pre></td></tr></table></figure>
<img src="/2017/04/10/quil-가지고-놀기/red_3_rect.png" alt="red_3_rect.png" title="">
<p><code>clojure</code>에는 <code>cycle</code>이라는 함수가 있어서 반복되는 값을 표현하기에 알맞다. 빨간색 사각형과 흰 사각형이 교대로 늘어서는 <code>모양</code>을 생각해보자. 이는 이렇게 표현할 수 있을 것이다.</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">(<span class="name">clojure.pprint/pprint</span> </div><div class="line">           (<span class="name"><span class="builtin-name">apply</span></span> beside </div><div class="line">            (<span class="name"><span class="builtin-name">take</span></span> <span class="number">10</span> </div><div class="line">                  (<span class="name"><span class="builtin-name">cycle</span></span></div><div class="line">                   [&#123;<span class="symbol">:type</span>   <span class="symbol">::rect</span></div><div class="line">                     <span class="symbol">:fill</span> [<span class="number">255</span> <span class="number">0</span> <span class="number">0</span>]</div><div class="line">                     <span class="symbol">:stroke</span> [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</div><div class="line">                     <span class="symbol">:offset-left</span> <span class="number">0</span></div><div class="line">                     <span class="symbol">:offset-top</span> <span class="number">0</span></div><div class="line">                     <span class="symbol">:width</span>  <span class="number">50</span></div><div class="line">                     <span class="symbol">:height</span> <span class="number">50</span>&#125;</div><div class="line">                    &#123;<span class="symbol">:type</span>   <span class="symbol">::rect</span></div><div class="line">                     <span class="symbol">:fill</span> [<span class="number">255</span> <span class="number">0</span> <span class="number">0</span>]</div><div class="line">                     <span class="symbol">:stroke</span> [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</div><div class="line">                     <span class="symbol">:offset-left</span> <span class="number">0</span></div><div class="line">                     <span class="symbol">:offset-top</span> <span class="number">0</span></div><div class="line">                     <span class="symbol">:width</span>  <span class="number">50</span></div><div class="line">                     <span class="symbol">:height</span> <span class="number">50</span>&#125;]))))</div></pre></td></tr></table></figure>
<p>이를 <code>repl</code> 에서 실행시켜 보면 <code>offset-left</code> 차이나는 10개의 <code>모양</code>맵들이 보일 것이다.<br><code>clojure.pprint/pprint</code> 함수는 데이터를 예쁘게 출력해주는 함수다.<br><code>draw-state</code>를 고치면 실제로 그려지는 모양을 확인할 수 있다.</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">defn</span></span> draw-state [state]</div><div class="line">  (<span class="name">background</span> <span class="number">255</span> <span class="number">255</span> <span class="number">255</span>)</div><div class="line">  (그리기! <span class="number">25</span> <span class="number">25</span></div><div class="line">           (<span class="name"><span class="builtin-name">apply</span></span> beside </div><div class="line">                  (<span class="name"><span class="builtin-name">take</span></span> <span class="number">10</span> </div><div class="line">                        (<span class="name"><span class="builtin-name">cycle</span></span></div><div class="line">                         [&#123;<span class="symbol">:type</span>   <span class="symbol">::rect</span></div><div class="line">                           <span class="symbol">:fill</span> [<span class="number">255</span> <span class="number">0</span> <span class="number">0</span>]</div><div class="line">                           <span class="symbol">:stroke</span> [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</div><div class="line">                           <span class="symbol">:offset-left</span> <span class="number">0</span></div><div class="line">                           <span class="symbol">:offset-top</span> <span class="number">0</span></div><div class="line">                           <span class="symbol">:width</span>  <span class="number">15</span></div><div class="line">                           <span class="symbol">:height</span> <span class="number">15</span>&#125;</div><div class="line">                          &#123;<span class="symbol">:type</span>   <span class="symbol">::rect</span></div><div class="line">                           <span class="symbol">:fill</span> [<span class="number">255</span> <span class="number">255</span> <span class="number">255</span>]</div><div class="line">                           <span class="symbol">:stroke</span> [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</div><div class="line">                           <span class="symbol">:offset-left</span> <span class="number">0</span></div><div class="line">                           <span class="symbol">:offset-top</span> <span class="number">0</span></div><div class="line">                           <span class="symbol">:width</span>  <span class="number">15</span></div><div class="line">                           <span class="symbol">:height</span> <span class="number">15</span>&#125;])))))</div></pre></td></tr></table></figure>
<p>이 <code>beside</code>와 비슷한 <code>above</code> 함수를 만들어보자. 이 함수는 가로가 아닌 세로로 늘어놓는 함수다.</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">defn</span></span> above</div><div class="line">  <span class="string">"모양들을 위아래로 늘어놓는다. 이때 가로가 가장 긴 모양의 가로축 중심을 기준으로 중앙정렬한다."</span></div><div class="line">  [&amp; 모양들]</div><div class="line">  (<span class="name"><span class="builtin-name">let</span></span> [가장-긴-가로길이 (<span class="name"><span class="builtin-name">apply</span></span> max (<span class="name"><span class="builtin-name">map</span></span> <span class="symbol">:width</span> 모양들))</div><div class="line">        자식요소  (<span class="name"><span class="builtin-name">loop</span></span> [모양들 모양들</div><div class="line">                         top    <span class="number">0</span></div><div class="line">                         result []]</div><div class="line">                    (<span class="name"><span class="builtin-name">if</span></span> 모양들 </div><div class="line">                      (<span class="name"><span class="builtin-name">let</span></span> [[지금-모양 &amp; 남은-모양] 모양들 </div><div class="line">                            &#123;<span class="symbol">:keys</span> [width height]&#125; 지금-모양</div><div class="line">                            left (<span class="name"><span class="builtin-name">quot</span></span> (<span class="name"><span class="builtin-name">-</span></span> 가장-긴-가로길이 width) <span class="number">2</span>)</div><div class="line">                            조정된-모양 (<span class="name"><span class="builtin-name">assoc</span></span> 지금-모양</div><div class="line">                                               <span class="symbol">:offset-left</span> left</div><div class="line">                                               <span class="symbol">:offset-top</span> top)] <span class="comment">;; 중앙정렬</span></div><div class="line">                        (<span class="name"><span class="builtin-name">recur</span></span> 남은-모양</div><div class="line">                               (<span class="name"><span class="builtin-name">+</span></span> top height)</div><div class="line">                               (<span class="name"><span class="builtin-name">conj</span></span> result 조정된-모양)))</div><div class="line">                      result))]</div><div class="line">    &#123;<span class="symbol">:type</span>        <span class="symbol">::grouped</span></div><div class="line">     <span class="symbol">:width</span>       가장-긴-가로길이</div><div class="line">     <span class="symbol">:height</span>      (<span class="name"><span class="builtin-name">reduce</span></span> + (<span class="name"><span class="builtin-name">map</span></span> <span class="symbol">:height</span> 모양들))</div><div class="line">     <span class="symbol">:offset-left</span> <span class="number">0</span></div><div class="line">     <span class="symbol">:offset-top</span>  <span class="number">0</span></div><div class="line">     <span class="symbol">:children</span>    자식요소&#125;))</div></pre></td></tr></table></figure>
<p>이제 이 모양들로 체스판을 만들어보자.</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">defn</span></span> draw-state [state]</div><div class="line">  (<span class="name">background</span> <span class="number">255</span> <span class="number">255</span> <span class="number">255</span>)</div><div class="line">  (그리기! <span class="number">25</span> <span class="number">25</span></div><div class="line">           (<span class="name"><span class="builtin-name">apply</span></span> above</div><div class="line">                  (<span class="name"><span class="builtin-name">take</span></span> <span class="number">10</span> </div><div class="line">                        (<span class="name"><span class="builtin-name">cycle</span></span></div><div class="line">                         [(<span class="name"><span class="builtin-name">apply</span></span> beside </div><div class="line">                                 (<span class="name"><span class="builtin-name">take</span></span> <span class="number">10</span> </div><div class="line">                                       (<span class="name"><span class="builtin-name">cycle</span></span></div><div class="line">                                        [&#123;<span class="symbol">:type</span>   <span class="symbol">::rect</span></div><div class="line">                                          <span class="symbol">:fill</span> [<span class="number">255</span> <span class="number">0</span> <span class="number">0</span>]</div><div class="line">                                          <span class="symbol">:stroke</span> [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</div><div class="line">                                          <span class="symbol">:offset-left</span> <span class="number">0</span></div><div class="line">                                          <span class="symbol">:offset-top</span> <span class="number">0</span></div><div class="line">                                          <span class="symbol">:width</span>  <span class="number">15</span></div><div class="line">                                          <span class="symbol">:height</span> <span class="number">15</span>&#125;</div><div class="line">                                         &#123;<span class="symbol">:type</span>   <span class="symbol">::rect</span></div><div class="line">                                          <span class="symbol">:fill</span> [<span class="number">255</span> <span class="number">255</span> <span class="number">255</span>]</div><div class="line">                                          <span class="symbol">:stroke</span> [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</div><div class="line">                                          <span class="symbol">:offset-left</span> <span class="number">0</span></div><div class="line">                                          <span class="symbol">:offset-top</span> <span class="number">0</span></div><div class="line">                                          <span class="symbol">:width</span>  <span class="number">15</span></div><div class="line">                                          <span class="symbol">:height</span> <span class="number">15</span>&#125;])))</div><div class="line">                          (<span class="name"><span class="builtin-name">apply</span></span> beside </div><div class="line">                                 (<span class="name"><span class="builtin-name">take</span></span> <span class="number">10</span> </div><div class="line">                                       (<span class="name"><span class="builtin-name">cycle</span></span></div><div class="line">                                        [&#123;<span class="symbol">:type</span>   <span class="symbol">::rect</span></div><div class="line">                                          <span class="symbol">:fill</span> [<span class="number">255</span> <span class="number">255</span> <span class="number">255</span>]</div><div class="line">                                          <span class="symbol">:stroke</span> [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</div><div class="line">                                          <span class="symbol">:offset-left</span> <span class="number">0</span></div><div class="line">                                          <span class="symbol">:offset-top</span> <span class="number">0</span></div><div class="line">                                          <span class="symbol">:width</span>  <span class="number">15</span></div><div class="line">                                          <span class="symbol">:height</span> <span class="number">15</span>&#125;</div><div class="line">                                         &#123;<span class="symbol">:type</span>   <span class="symbol">::rect</span></div><div class="line">                                          <span class="symbol">:fill</span> [<span class="number">255</span> <span class="number">0</span> <span class="number">0</span>]</div><div class="line">                                          <span class="symbol">:stroke</span> [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</div><div class="line">                                          <span class="symbol">:offset-left</span> <span class="number">0</span></div><div class="line">                                          <span class="symbol">:offset-top</span> <span class="number">0</span></div><div class="line">                                          <span class="symbol">:width</span>  <span class="number">15</span></div><div class="line">                                          <span class="symbol">:height</span> <span class="number">15</span>&#125;])))])))))</div></pre></td></tr></table></figure>
<img src="/2017/04/10/quil-가지고-놀기/red_chess.png" alt="red_chess.png" title="">
<p>일단 <code>::grouped</code> 모양을 만들면 이 모양을 <code>그리기!</code>하는 함수는 이미 있으므로 이 <code>모양</code>을 다시 <code>cycle</code>을 하든 그걸 다시 <code>above</code>로 묶던 내부적으로 이를 그리는 방법은 신경 쓸 필요가 없다.</p>
<p>이제 이 함수를 가지고 <code>plt-racket</code>의 홈페이지 대문 예제 중 하나인 시어핀스키의 삼각형을 그려보자.</p>
<p>먼저 삼각형을 <code>그리기!</code>하는 함수를 만들어보면,</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">defmethod</span></span> 그리기!</div><div class="line">  <span class="symbol">::triangle</span></div><div class="line">  [left top 모양]</div><div class="line">  (<span class="name"><span class="builtin-name">let</span></span> [&#123;<span class="symbol">:keys</span> [offset-left</div><div class="line">                offset-top</div><div class="line">                width</div><div class="line">                height</div><div class="line">                stroke</div><div class="line">                fill]&#125; 모양]</div><div class="line">    (<span class="name"><span class="builtin-name">when</span></span> stroke</div><div class="line">      (<span class="name"><span class="builtin-name">apply</span></span> quil.core/stroke stroke))</div><div class="line">    (<span class="name"><span class="builtin-name">when</span></span> (<span class="symbol">:fill</span> 모양)</div><div class="line">      (<span class="name"><span class="builtin-name">apply</span></span> quil.core/fill fill))</div><div class="line">    (<span class="name"><span class="builtin-name">let</span></span> [left (<span class="name"><span class="builtin-name">+</span></span> left offset-left)</div><div class="line">          top (<span class="name"><span class="builtin-name">+</span></span> top offset-top)]</div><div class="line">      (<span class="name">triangle</span> (<span class="name"><span class="builtin-name">+</span></span> left (<span class="name"><span class="builtin-name">quot</span></span> width <span class="number">2</span>)) top</div><div class="line">                left                    (<span class="name"><span class="builtin-name">+</span></span> top height)</div><div class="line">                (<span class="name"><span class="builtin-name">+</span></span> left width)          (<span class="name"><span class="builtin-name">+</span></span> top height)))))</div></pre></td></tr></table></figure>
<blockquote>
<p>이렇게 하면 사실 정삼각형을 그리기 힘들다 (가로 세로만 입력가능하니까..)</p>
</blockquote>
<p>또, 시어핀스키의 삼각형을 만드는 함수를 만들어보자. <code>above</code>, <code>beside</code> 면 간단히 만들 수 있다.</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">defn</span></span> sierpinski [n]</div><div class="line">  (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">zero?</span></span> n) </div><div class="line">    &#123;<span class="symbol">:type</span>   <span class="symbol">::triangle</span></div><div class="line">     <span class="symbol">:width</span>  <span class="number">10</span></div><div class="line">     <span class="symbol">:height</span> <span class="number">8.66</span>&#125;</div><div class="line">    (<span class="name"><span class="builtin-name">let</span></span> [result (<span class="name">sierpinski</span> (<span class="name"><span class="builtin-name">dec</span></span> n))]</div><div class="line">      (<span class="name">above</span> result</div><div class="line">             (<span class="name">beside</span> result result)))))</div></pre></td></tr></table></figure>
<p><code>draw-state</code>를 고쳐서 확인해보자.</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">defn</span></span> draw-state [state]</div><div class="line">  (<span class="name">background</span> <span class="number">255</span> <span class="number">255</span> <span class="number">255</span>)</div><div class="line">  (<span class="name">no-stroke</span>)</div><div class="line">  (그리기! <span class="number">40</span> <span class="number">40</span> (<span class="name">sierpinski</span> <span class="number">5</span>)))</div><div class="line"></div><div class="line"><span class="comment">;; 윈도우 사이즈를 400으로 늘림.</span></div><div class="line">(<span class="name">defsketch</span> foo</div><div class="line">  <span class="symbol">:title</span> <span class="string">"foo"</span></div><div class="line">  <span class="symbol">:size</span> [<span class="number">400</span> <span class="number">400</span>]</div><div class="line">  <span class="symbol">:setup</span> setup</div><div class="line">  <span class="symbol">:draw</span> draw-state</div><div class="line">  <span class="symbol">:features</span> [<span class="symbol">:keep-on-top</span>]</div><div class="line">  <span class="symbol">:middleware</span> [m/fun-mode])</div></pre></td></tr></table></figure>
<img src="/2017/04/10/quil-가지고-놀기/sierpinski.png" alt="sierpinski.png" title="">
<link href="/css/prism-dark.css" rel="stylesheet"></div><footer class="post__foot u-cf"><ul class="post__tag u-fl"><li class="post__tag__item"><a href="/tags/clojure/" class="post__tag__link">clojure</a></li><li class="post__tag__item"><a href="/tags/quil/" class="post__tag__link">quil</a></li><li class="post__tag__item"><a href="/tags/processing/" class="post__tag__link">processing</a></li><li class="post__tag__item"><a href="/tags/sierpinski/" class="post__tag__link">sierpinski</a></li></ul><a href="/2017/04/10/quil-가지고-놀기/#disqus_thread" class="post__foot-link u-fr">0 COMMENTS</a></footer></article><div class="comments"><div id="disqus_thread"><noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a>
</noscript></div></div></main><footer class="foot"><div class="foot-copy u-fl">&copy; 2017 euhyen ~_~</div><menu class="page-menu u-fr"><li class="page-menu__item"><span title="Previous" class="page-menu__link icon-arrow-left page-menu__link--disabled"></span></li><li class="page-menu__item"><a title="Next" href="/2017/02/26/구조분해/" class="page-menu__link icon-arrow-right"></a></li></menu></footer><script>(function(h,g,l,k,j,i){j=h.createElement(g),i=h.getElementsByTagName(g)[0],
j.src="//"+l+".disqus.com/"+k+".js",i.parentNode.insertBefore(j,i)})
(document,"script","ehjanghexo","embed");
</script></body></html>